// ~~ Generated by projen. To modify, edit .projenrc.ts and run "npx projen".
import type { AssetHashType, aws_iam, BundlingOptions, IgnoreMode, interfaces, SymlinkFollowMode } from 'aws-cdk-lib';

/**
 * OptionalAssetProps
 */
export interface OptionalAssetProps {
  /**
   * The disk location of the asset.
   * The path should refer to one of the following:
   * - A regular file or a .zip file, in which case the file will be uploaded as-is to S3.
   * - A directory, in which case it will be archived into a .zip file and uploaded to S3.
   * @stability stable
   */
  readonly path?: string;
  /**
   * The ARN of the KMS key used to encrypt the handler code.
   * @default - the default server-side encryption with Amazon S3 managed keys(SSE-S3) key will be used.
   * @stability stable
   */
  readonly sourceKMSKey?: interfaces.aws_kms.IKeyRef;
  /**
   * A list of principals that should be able to read this asset from S3.
   * You can use `asset.grantRead(principal)` to grant read permissions later.
   * @default - No principals that can read file asset.
   * @stability stable
   */
  readonly readers?: Array<aws_iam.IGrantable>;
  /**
   * A display name for this asset.
   * If supplied, the display name will be used in locations where the asset
   * identifier is printed, like in the CLI progress information. If the same
   * asset is added multiple times, the display name of the first occurrence is
   * used.
   *
   * The default is the construct path of the Asset construct, with respect to
   * the enclosing stack. If the asset is produced by a construct helper
   * function (such as `lambda.Code.fromAsset()`), this will look like
   * `MyFunction/Code`.
   *
   * We use the stack-relative construct path so that in the common case where
   * you have multiple stacks with the same asset, we won't show something like
   * `/MyBetaStack/MyFunction/Code` when you are actually deploying to
   * production.
   * @default - Stack-relative construct path
   * @stability stable
   */
  readonly displayName?: string;
  /**
   * Whether or not the asset needs to exist beyond deployment time;
   * i.e.
   * are copied over to a different location and not needed afterwards.
   * Setting this property to true has an impact on the lifecycle of the asset,
   * because we will assume that it is safe to delete after the CloudFormation
   * deployment succeeds.
   *
   * For example, Lambda Function assets are copied over to Lambda during
   * deployment. Therefore, it is not necessary to store the asset in S3, so
   * we consider those deployTime assets.
   * @default false
   * @stability stable
   */
  readonly deployTime?: boolean;
  /**
   * The ignore behavior to use for `exclude` patterns.
   * @default IgnoreMode.GLOB
   * @stability stable
   */
  readonly ignoreMode?: IgnoreMode;
  /**
   * A strategy for how to handle symlinks.
   * @default SymlinkFollowMode.NEVER
   * @stability stable
   */
  readonly followSymlinks?: SymlinkFollowMode;
  /**
   * File paths matching the patterns will be excluded.
   * See `ignoreMode` to set the matching behavior.
   * Has no effect on Assets bundled using the `bundling` property.
   * @default - nothing is excluded
   * @stability stable
   */
  readonly exclude?: Array<string>;
  /**
   * Bundle the asset by executing a command in a Docker container or a custom bundling provider.
   * The asset path will be mounted at `/asset-input`. The Docker
   * container is responsible for putting content at `/asset-output`.
   * The content at `/asset-output` will be zipped and used as the
   * final asset.
   * @default - uploaded as-is to S3 if the asset is a regular file or a .zip file,
archived into a .zip file and uploaded to S3 otherwise
   * @stability stable
   */
  readonly bundling?: BundlingOptions;
  /**
   * Specifies the type of hash to calculate for this asset.
   * If `assetHash` is configured, this option must be `undefined` or
   * `AssetHashType.CUSTOM`.
   * @default - the default is `AssetHashType.SOURCE`, but if `assetHash` is
explicitly specified this value defaults to `AssetHashType.CUSTOM`.
   * @stability stable
   */
  readonly assetHashType?: AssetHashType;
  /**
   * Specify a custom hash for this asset.
   * If `assetHashType` is set it must
   * be set to `AssetHashType.CUSTOM`. For consistency, this custom hash will
   * be SHA256 hashed and encoded as hex. The resulting hash will be the asset
   * hash.
   *
   * NOTE: the hash is used in order to identify a specific revision of the asset, and
   * used for optimizing and caching deployment activities related to this asset such as
   * packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will
   * need to make sure it is updated every time the asset changes, or otherwise it is
   * possible that some deployments will not be invalidated.
   * @default - based on `assetHashType`
   * @stability stable
   */
  readonly assetHash?: string;
}
