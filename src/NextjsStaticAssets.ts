import { RemovalPolicy, Stack } from 'aws-cdk-lib';
import * as s3 from 'aws-cdk-lib/aws-s3';
import { Asset } from 'aws-cdk-lib/aws-s3-assets';
import { Construct } from 'constructs';
import * as fs from 'node:fs';
import { tmpdir } from 'node:os';
import { resolve } from 'node:path';

import { CACHE_BUCKET_KEY_PREFIX } from './constants';
import { OptionalAssetProps, OptionalNextjsBucketDeploymentProps } from './generated-structs';
import { NextjsBucketDeployment } from './NextjsBucketDeployment';
import { NextjsBuild } from './NextjsBuild';

export interface NextjsStaticAssetOverrides {
  readonly bucketProps?: s3.BucketProps;
  readonly nextjsBucketDeploymentProps?: OptionalNextjsBucketDeploymentProps;
  readonly assetProps?: OptionalAssetProps;
}

export interface NextjsStaticAssetsProps {
  /**
   * Optional value to prefix the Next.js site under a /prefix path on CloudFront.
   * Usually used when you deploy multiple Next.js sites on same domain using /sub-path
   *
   * Note, you'll need to set [basePath](https://nextjs.org/docs/app/api-reference/next-config-js/basePath)
   * in your `next.config.ts` to this value and ensure any files in `public`
   * folder have correct prefix.
   * @example "/my-base-path"
   */
  readonly basePath?: string;
  /**
   * Define your own bucket to store static assets.
   */
  readonly bucket?: s3.IBucket | undefined;
  /**
   * Custom environment variables to pass to the NextJS build and runtime.
   */
  readonly environment?: Record<string, string>;
  /**
   * The `NextjsBuild` instance representing the built Nextjs application.
   */
  readonly nextBuild: NextjsBuild;
  /**
   * Override props for every construct.
   */
  readonly overrides?: NextjsStaticAssetOverrides;
  /**
   * If `true` (default), then removes old static assets after upload new static assets.
   * @default true
   */
  readonly prune?: boolean;
}

/**
 * Uploads Nextjs built static and public files to S3.
 *
 * Will inject resolved environment variables that are unresolved at synthesis
 * in CloudFormation Custom Resource.
 */
export class NextjsStaticAssets extends Construct {
  /**
   * Bucket containing assets.
   */
  bucket: s3.IBucket;

  protected props: NextjsStaticAssetsProps;

  private get buildEnvVars() {
    const buildEnvVars: Record<string, string> = {};
    for (const [k, v] of Object.entries(this.props.environment || {})) {
      if (k.startsWith('NEXT_PUBLIC')) {
        buildEnvVars[k] = v;
      }
    }
    return buildEnvVars;
  }

  constructor(scope: Construct, id: string, props: NextjsStaticAssetsProps) {
    super(scope, id);
    this.props = props;

    this.bucket = this.createBucket();

    // when `cdk deploy "NonNextjsStack" --exclusively` is run, don't bundle assets since they will not exist
    if (Stack.of(this).bundlingRequired) {
      const asset = this.createAsset();
      this.createBucketDeployment(asset);
    }
  }

  private createBucket(): s3.IBucket {
    return (
      this.props.bucket ??
      new s3.Bucket(this, 'Bucket', {
        removalPolicy: RemovalPolicy.DESTROY,
        autoDeleteObjects: true,
        enforceSSL: true,
        blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
        encryption: s3.BucketEncryption.S3_MANAGED,
        ...this.props.overrides?.bucketProps,
      })
    );
  }

  private createAsset(): Asset {
    // create temporary directory to join open-next's static output with cache output
    const tmpAssetsDir = fs.mkdtempSync(resolve(tmpdir(), 'cdk-nextjs-assets-'));

    // 1) Copy static files generated by open-next
    const staticDir = this.props.nextBuild.nextStaticDir;
    if (fs.existsSync(staticDir)) {
      fs.cpSync(staticDir, tmpAssetsDir, {
        recursive: true,
      });
    } else {
      console.warn(`Warning: static directory not found at ${staticDir}, skipping copy.`);
    }

    // 2) Copy cache directory only if it exists in the open-next output
    const cacheDir = this.props.nextBuild.nextCacheDir;
    if (fs.existsSync(cacheDir)) {
      fs.cpSync(cacheDir, resolve(tmpAssetsDir, CACHE_BUCKET_KEY_PREFIX), {
        recursive: true,
      });
    } else {
      // Silently ignore if missing â€“ just print a warning
      console.warn(`Warning: cache directory not found at ${cacheDir}, skipping copy.`);
    }

    const asset = new Asset(this, 'Asset', {
      path: tmpAssetsDir,
      ...this.props.overrides?.assetProps,
    });
    fs.rmSync(tmpAssetsDir, { recursive: true });
    return asset;
  }

  private createBucketDeployment(asset: Asset) {
    const basePath = this.props.basePath?.replace(/^\//, ''); // remove leading slash (if present)
    const staticFiles = '**/_next/static/**/*';

    return new NextjsBucketDeployment(this, 'BucketDeployment', {
      asset,
      destinationBucket: this.bucket,
      destinationKeyPrefix: basePath,
      debug: true,
      // only put env vars that are placeholders in custom resource properties
      // to be replaced. other env vars were injected at build time.
      substitutionConfig: NextjsBucketDeployment.getSubstitutionConfig(this.buildEnvVars),
      prune: this.props.prune, // defaults to false
      putConfig: {
        [staticFiles]: {
          CacheControl: 'public, max-age=31536000, immutable',
        },
      },
      ...this.props.overrides?.nextjsBucketDeploymentProps,
    });
  }
}
